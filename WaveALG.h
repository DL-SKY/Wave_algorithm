//========================================================================
//            ВОЛНОВОЙ АЛГОРИТМ нахождения кратчайшего пути
//                   от точки A(x0;y0) до B(x1;y1)
//
//А.Даниловский ©26.02.2013
//========================================================================
const int iSize = 10;	//Размерность матрицы

int iMap[10][10];	//Карта; 0 - свободно, 1 - препятсвие
int iStepMap[10][10];	//Карта шагов; содержит число шагов до ФИНИША в текущей координате;
						// -1 - не посещали, -2 - препятствие
int iResultX[100];	//X-координата пути; [0] - точка НАЧАЛА
int iResultY[100];	//Y-координата пути; [0] - точка НАЧАЛА

//------------------------------------------------------------------------
//------------------------------------------------------------------------
//x0, y0 - начальная координата; x1, y1 - конечная координата
//волну начинаем запускать с точки назначения
bool WaveStart(int x0, int y0, int x1, int y1)
{
//объявление и инициализация

int iStep;	//Шаг; изначально равен 0
//int iI;
bool bResult = false,	//Путь найден
	 bAdded = true;	//Внесены изменения; для контроля цикла

for ( int i = 0; i < iSize; i++ )
	for ( int j = 0; j < iSize; j++ )
		{
		if( iMap[i][j] != 0 )
			iStepMap[i][j] = -2;	//препятствие
		else
			iStepMap[i][j] = -1;	//не посещено
		}

for ( int i = 0; i < 99; i++ )
	{
	iResultX[i] = -1;
	iResultY[i] = -1;
	}

iStep = 0;
//--------
iStepMap[x1][y1] = iStep;
//--------
//проверка координат на свободно/занято
if ( iMap[x0][y0] == 1 || iMap[x1][y1] == 1 )
	{
	bResult = false;

	return bResult;
	}
//Начало ВОЛНЫ. пускаем волну
while ( bAdded && iStepMap[x0][y0] == -1 )
	{
	bAdded = false;	//ничего еще не добавили
	iStep++;	//Увеличиваем число шагов

	for (  int i = 0; i < iSize; i++ )	// Пробегаем по всей карте
		for ( int j = 0; j < iSize; j++ )
			//Если точка с координатами (i;j) обрабатывалась на
			//предыдущем шаге, то обрабатываем соседние клетки
			if ( iStepMap[i][j] == iStep-1 )
			{
			int _i, _j;
			_i = i;
			_j = j;
			
			for (int k = 0; k<4; k++)
				{
				//последовательно перебираем соседние точки
				//и обрабатываем их
				switch(k)
					{
					case 0 : _i = i+1; _j = j; break;
					case 1 : _i = i-1; _j = j; break;
					case 2 : _i = i; _j = j+1; break;
					case 3 : _i = i; _j = j-1; break;
					}
				//проверяем клетки на принадлежность матрице
				//и на то, обрабатывалась ли она (-1)
				if ( _i >= 0 && _j >= 0 && _i < iSize && _j < iSize )
					if( iStepMap[_i][_j] == -1 )
						{
						iStepMap[_i][_j] = iStep;
						bAdded = true;
						}
				}
			}
	}
//Конец ВОЛНЫ.

//Обработка результатов ВОЛНЫ
//Если начальная точка (x0,y0) не обработана (=-1, =-2), то ПУТЬ не найден
// -1 - не посещали, -2 - препятствие
if ( iStepMap[x0][y0] == -1 || iStepMap[x0][y0] == -2 )
	bResult = false;
else if (iStepMap[x0][y0] >= 0)
	{
	bResult = true;
	//WavePath(x0, y0);
	}

return bResult;
}
//------------------------------------------------------------------------
//------------------------------------------------------------------------
void PathResult(int x0, int y0, int x1, int y1)
{
int iStep = iStepMap[x0][y0];
int iI = 0;
int x = x0, y = y0;	//координаты предыдущей точки маршрута
bool bAdded = true;	//Внесены изменения; для контроля цикла

iResultX[iI] = x0;
iResultY[iI] = y0;

if (x0 == x1 && y0 == y1)
	{
	iResultX[iI] = x1;
	iResultY[iI] = y1;
	return ;
	}

//Начало СОХРАНЕНИЯ ПУТИ. пускаем волну
while ( bAdded && iStep >= 0)
	{
	bAdded = false;	//ничего еще не добавили
	iI++;		//номер следующей точки найденного маршрута
	iStep--;	//Увеличиваем число шагов

	for (  int i = 0; i < iSize; i++ )	// Пробегаем по всей карте
		for ( int j = 0; j < iSize; j++ )
			//Если точка с координатами (i;j) обрабатывалась на
			//предыдущем шаге, то обрабатываем соседние клетки
			if ( iStepMap[i][j] == iStep )
			{
			int _i, _j;
			_i = i;
			_j = j;

			for (int k = 0; k<4; k++)
				{
				//последовательно перебираем соседние точки
				//и обрабатываем их
				switch(k)
					{
					case 0 : _i = i; _j = j-1; break;
					case 1 : _i = i+1; _j = j; break;
					case 2 : _i = i; _j = j+1; break;
					case 3 : _i = i-1; _j = j; break;
					}
				//проверяем клетки на принадлежность матрице
				if ( _i >= 0 && _j >= 0 && _i < iSize && _j < iSize )
					if( _i == x && _j == y )
						{
						iResultX[iI] = _i;
						iResultY[iI] = _j;
						x = i;
						y = j;

						bAdded = true;
						}
				}
			}
	}
//Конец СОХРАНЕНИЯ ПУТИ.
iResultX[iI+1] = x1;
iResultY[iI+1] = y1;

return ;
}
//------------------------------------------------------------------------
//============= ПРИМЕР ИСПОЛЬЗОВАНИЯ ====================
//------------------------------------------------------------------------
/*
if ( !WaveStart(x0, y0, x1, y1) )
	{
	Label1->Caption = "Пути не существует";
    Form1->Paint();
	}
else
	{
	Label1->Caption = "Путь найден";

	Form1->Paint();

	PathResult(x0, y0, x1, y1);

	for ( int i = 0; i < 99; i++ )
		if ( iResultX[i] != -1 && iResultY[i] != -1)
			{
			Form1->Canvas->Brush->Color=clWhite;
			Form1->Canvas->Rectangle(iResultX[i]*30,iResultY[i]*30,iResultX[i]*30+30,iResultY[i]*30+30);
			}
	}
*/
